- name: Create groups for users
  ansible.builtin.group:
    name: "{{ item.username }}"
    state: present
  loop: "{{ users_add_userlist | default([]) }}"

- name: Create user accounts and force password change on first login
  ansible.builtin.user:
    name: "{{ item.username }}"
    state: present
    group: "{{ item.username }}"  # Ensures a group with the username is created/used as the primary group
    comment: "{{ item.username }} account. Is admin? {{ item.admin }}"
    shell: /bin/bash
    password: "{{ item.initialpassword | default(GENERALINITIALPASSWORD) | password_hash('sha512') }}"
      # Initial password required for sudo - must be changed on first login
    update_password: on_create  # This ensures the password is only set when the user is created
  loop: "{{ users_add_userlist | default([]) }}"
  notify:
    - Force password change on first login
  no_log: true  # Prevent password hashes from being logged

- name: Add additional public keys
  ansible.posix.authorized_key:
    key: "{{ item.public_key }}"
    user: "{{ item.username }}"
    state: present
    comment: "{{ item.username }} key"
  loop: "{{ users_add_userlist | default([]) }}"

- name: Add all users who should be admin to sudo
  ansible.builtin.lineinfile:
    path: "/etc/sudoers.d/{{ item.username }}"
    line: "{{ item.username }} ALL=(ALL) ALL"
    state: present
    mode: '0440'
    create: true
    validate: '/usr/sbin/visudo -cf %s'
  loop: "{{ users_add_userlist | default([]) }}"
  when: item.admin

- name: Allow non-admin users to run system updates/upgrades
  ansible.builtin.blockinfile:
    path: "/etc/sudoers.d/{{ item.username }}"
    block: |
      # ===================================================================
      # Limited sudo access for user: {{ item.username }}.
      # ===================================================================
      #
      # This user is granted limited sudo privileges for system maintenance.
      #
      # ALLOWED COMMANDS: {{ item.non_admin_allowed_commands }}
      #
      # To see this help again, run: sudo cat /etc/sudoers.d/{{ item.username }}
      # ===================================================================

      # Show lecture message on sudo use
      Defaults:{{ item.username }} lecture = always
      Defaults:{{ item.username }} lecture_file = /etc/sudoers.d/.{{ item.username }}_lecture

      # Actual sudo rules:
      {{ item.username }} ALL=(ALL) {{ item.non_admin_allowed_commands }}
    state: present
    create: true
    mode: '0440'
    validate: '/usr/sbin/visudo -cf %s'
  loop: "{{ users_add_userlist | default([]) }}"
  when:
    - not item.admin
    - item.non_admin_allowed_commands is defined
    - item.non_admin_allowed_commands | length > 0

- name: Create sudo lecture file for non-admin users
  ansible.builtin.copy:
    dest: "/etc/sudoers.d/.{{ item.username }}_lecture"
    content: |

      ===============================================================================
      NOTICE: Limited sudo access for {{ item.username }}. Abuse attempts are logged.
      ===============================================================================

      You have restricted sudo privileges. Your allowed commands are:
      {{ item.non_admin_allowed_commands }}

      Example usage:
        sudo apt update
        sudo apt upgrade
        sudo reboot

      ===============================================================================

    mode: '0644'
    owner: root
    group: root
  loop: "{{ users_add_userlist | default([]) }}"
  when:
    - not item.admin
    - item.non_admin_allowed_commands is defined
    - item.non_admin_allowed_commands | length > 0

- name: Set includedir in sudoers to make sure our additions work
  ansible.builtin.lineinfile:
    dest: /etc/sudoers
    line: "#includedir /etc/sudoers.d"
    state: present
    validate: "/usr/sbin/visudo -cf %s"

# ===================================================================
# MOTD SECURITY WARNINGS SECTION
# Add custom MOTD script to warn about pending updates and reboots
# ===================================================================

- name: Create simple CIS-compliant MOTD script (read-only)
  ansible.builtin.copy:
    dest: /etc/update-motd.d/95-security-warnings
    mode: '0444'
    content: |
      #!/bin/bash
      # Simple CIS-compliant MOTD script for security warnings
      # Content is generated by /usr/local/bin/update-security-status

      # Display pre-generated security status if available
      if [ -f /var/cache/motd-security-status ]; then
          cat /var/cache/motd-security-status
      else
          printf "\n=== SYSTEM SECURITY STATUS ===\n"
          printf "Security status: Checking...\n"
          printf "==============================\n\n"
      fi


- name: Ensure update-notifier-common is installed for reboot detection (Ubuntu only)
  ansible.builtin.package:
    name: update-notifier-common
    state: present
  failed_when: false  # Don't fail if package doesn't exist
  when: ansible_facts["distribution"] == "Ubuntu"

- name: Create cache directory for MOTD security status
  ansible.builtin.file:
    path: /var/cache
    state: directory
    mode: '0755'
    owner: root
    group: root

- name: Create security status generator script
  ansible.builtin.copy:
    dest: /usr/local/bin/update-security-status
    mode: '0755'
    content: |
      #!/bin/bash
      # Script to generate security status for MOTD display
      # This script contains all the complex logic and generates a cache file

      # Output file for MOTD content
      OUTPUT_FILE="/var/cache/motd-security-status"
      TEMP_FILE="${OUTPUT_FILE}.tmp"

      # Colors for output
      RED='\033[0;31m'
      YELLOW='\033[1;33m'
      GREEN='\033[0;32m'
      NC='\033[0m' # No Color

      # Function to write to output
      write_output() {
          printf "$@" >> "$TEMP_FILE"
      }

      # Start generating content
      write_output "\n"
      write_output "=== SYSTEM SECURITY STATUS (updated hourly) ===\n"

      # Update package cache for accurate counts
      apt-get update >/dev/null 2>&1

      # Check for pending security updates
      if command -v apt-get >/dev/null 2>&1; then
          # Check for security updates
          SECURITY_UPDATES=$(apt-get -s upgrade 2>/dev/null | grep -i security | wc -l)
          TOTAL_UPDATES=$(apt list --upgradable 2>/dev/null | grep -c upgradable)

          if [ "$SECURITY_UPDATES" -gt 0 ]; then
              write_output "${RED}âš ï¸  WARNING: $SECURITY_UPDATES security updates pending!${NC}\n"
              write_output "${YELLOW}   Run: sudo apt update && sudo apt upgrade${NC}\n"
          elif [ "$TOTAL_UPDATES" -gt 0 ]; then
              write_output "${YELLOW}â„¹ï¸  Info: $TOTAL_UPDATES package updates available${NC}\n"
          else
              write_output "${GREEN}âœ… System packages are up to date${NC}\n"
          fi
      fi

      # Check for pending reboot
      REBOOT_REQUIRED=false
      REBOOT_REASON=""

      # Method 1: Check /var/run/reboot-required (Ubuntu with update-notifier-common)
      if [ -f /var/run/reboot-required ]; then
          REBOOT_REQUIRED=true
          REBOOT_REASON="System packages"
          if [ -f /var/run/reboot-required.pkgs ]; then
              write_output "${RED}ðŸ”„ WARNING: System reboot required!${NC}\n"
              write_output "${YELLOW}   Packages requiring reboot:${NC}\n"
              cat /var/run/reboot-required.pkgs | sed 's/^/     - /' >> "$TEMP_FILE"
          fi
      fi

      # Method 2: Check for kernel updates (works on most Linux distributions)
      RUNNING_KERNEL=$(uname -r)
      if [ -d /boot ]; then
          LATEST_KERNEL=$(ls /boot/vmlinuz-* 2>/dev/null | sed 's/.*vmlinuz-//' | sort -V | tail -1)
          if [ -n "$LATEST_KERNEL" ] && [ "$RUNNING_KERNEL" != "$LATEST_KERNEL" ]; then
              REBOOT_REQUIRED=true
              REBOOT_REASON="Kernel update (running: $RUNNING_KERNEL, available: $LATEST_KERNEL)"
          fi
      fi

      # Method 3: Check for process restarts needed (systemd systems)
      if command -v systemctl >/dev/null 2>&1; then
          NEEDS_RESTART=$(systemctl list-units --state=failed --no-legend 2>/dev/null | wc -l)
          if [ "${NEEDS_RESTART:-0}" -gt 0 ]; then
              REBOOT_REASON="${REBOOT_REASON:+$REBOOT_REASON, }Failed services detected"
          fi
      fi

      if [ "$REBOOT_REQUIRED" = true ]; then
          write_output "${RED}ðŸ”„ WARNING: System reboot required!${NC}\n"
          write_output "${YELLOW}   Reason: $REBOOT_REASON${NC}\n"
          write_output "${YELLOW}   Run: sudo reboot${NC}\n"
      else
          write_output "${GREEN}âœ… No reboot required${NC}\n"
      fi

      # Check last reboot time with multiple fallback methods
      LAST_BOOT=""

      if [ -z "$LAST_BOOT" ] && command -v uptime >/dev/null 2>&1; then
          LAST_BOOT=$(uptime -s 2>/dev/null)
      fi

      # Fallback
      if [ -z "$LAST_BOOT" ]; then
          LAST_BOOT="unknown"
      fi

      write_output "â„¹ï¸  Last boot: $LAST_BOOT\n"

      # Check system uptime
      UPTIME=$(uptime | awk -F'up ' '{print $2}' | awk -F', load' '{print $1}')
      write_output "â„¹ï¸  Uptime: $UPTIME\n"

      write_output "==============================\n"
      write_output "\n"

      # Atomically move temp file to final location
      mv "$TEMP_FILE" "$OUTPUT_FILE"

      # Set proper permissions
      chmod 644 "$OUTPUT_FILE"

      # For Debian systems without update-motd, also update dynamic MOTD
      if ! command -v update-motd >/dev/null 2>&1; then
          cp "$OUTPUT_FILE" /var/run/motd.dynamic 2>/dev/null || true
      fi

- name: Create systemd service for MOTD security updates
  ansible.builtin.copy:
    dest: /etc/systemd/system/update-motd-security.service
    mode: '0644'
    content: |
      [Unit]
      Description=Update MOTD Security Status
      After=network.target

      [Service]
      Type=oneshot
      ExecStart=/usr/local/bin/update-security-status
      User=root

- name: Create systemd timer for MOTD security updates
  ansible.builtin.copy:
    dest: /etc/systemd/system/update-motd-security.timer
    mode: '0644'
    content: |
      [Unit]
      Description=Update MOTD Security Status Timer
      Requires=update-motd-security.service

      [Timer]
      OnCalendar=hourly
      Persistent=true

      [Install]
      WantedBy=timers.target

- name: Enable and start systemd timer for MOTD updates
  ansible.builtin.systemd:
    name: update-motd-security.timer
    enabled: true
    state: started
    daemon_reload: true

- name: Setup MOTD for Debian systems
  when: ansible_facts["os_family"] == "Debian"
  block:
    - name: Check if this is a Debian-based system without update-motd
      ansible.builtin.command: which update-motd
      register: users_add_update_motd_exists
      failed_when: false
      changed_when: false

    - name: Ensure PAM MOTD configuration for Ubuntu
      ansible.builtin.lineinfile:
        path: /etc/pam.d/sshd
        line: "session optional pam_motd.so motd=/run/motd.dynamic"
        insertafter: "# Print the message of the day upon successful login"
        state: present
      when: ansible_facts["distribution"] == "Ubuntu" and users_add_update_motd_exists.rc != 0

    - name: Create PAM MOTD configuration for Debian
      ansible.builtin.lineinfile:
        path: /etc/pam.d/sshd
        line: "session optional pam_motd.so motd=/var/cache/motd-security-status"
        insertafter: "# Print the message of the day upon successful login"
        state: present
      become: true
      when: ansible_facts["distribution"] == "Debian" and users_add_update_motd_exists.rc != 0

    - name: Generate initial security status and dynamic MOTD
      ansible.builtin.command: /usr/local/bin/update-security-status
      when: users_add_update_motd_exists.rc != 0
      changed_when: false

    - name: Ensure cache file permissions
      ansible.builtin.file:
        path: /var/cache/motd-security-status
        owner: root
        group: root
        mode: '0644'
        state: touch
      when: users_add_update_motd_exists.rc != 0
# ===================================================================
# 2FA (TOTP) CONFIGURATION SECTION
# ===================================================================

- name: Create no2fa group for service accounts (exempt from 2FA)
  ansible.builtin.group:
    name: no2fa
    state: present
    system: true
  when: enable_2fa | default(false)

- name: Add service accounts to no2fa group
  ansible.builtin.user:
    name: "{{ item.username }}"
    groups: no2fa
    append: true
  loop: "{{ users_add_userlist | default([]) }}"
  when:
    - enable_2fa | default(false)
    - item.enable_2fa is defined
    - not item.enable_2fa

- name: Install libpam-google-authenticator
  ansible.builtin.package:
    name: libpam-google-authenticator
    state: present
  when: enable_2fa | default(false)

- name: Create 2FA secrets directory
  ansible.builtin.file:
    path: /var/lib/google-authenticator
    state: directory
    owner: root
    group: root
    mode: '0700'
  when: enable_2fa | default(false)

- name: Install qrencode for QR code display
  ansible.builtin.package:
    name: qrencode
    state: present
  when: enable_2fa | default(false)

- name: Create 2FA enrollment script (pam_exec approach)
  ansible.builtin.copy:
    dest: /usr/local/sbin/ga-enroll-if-needed
    owner: root
    group: root
    mode: '0755'
    content: |
      #!/bin/sh
      set -eu

      user="${PAM_USER:?missing PAM_USER}"
      base="/var/lib/google-authenticator"
      secret="$base/$user"

      # Already enrolled?
      if [ -s "$secret" ]; then
        exit 0
      fi

      umask 077
      mkdir -p "$base"
      chmod 0700 "$base"

      echo "==============================================================================="
      echo "SECURITY REQUIREMENT: Two-Factor Authentication (2FA) Setup"
      echo "==============================================================================="
      echo "You must set up TOTP-based 2FA (Aegis, Google Authenticator, Authy, Bitwarden, etc.)"
      echo "Please scan the QR code below with your authenticator app."
      echo "Save the emergency scratch codes in a secure location."
      echo ""

      # Run enrollment with all options pre-configured
      # -t: time-based TOTP
      # -d: disallow token reuse (security)
      # -f: force write without confirmation
      # -r 3: rate limit to 3 attempts
      # -R 30: rate limit window of 30 seconds
      # -w 3: window of 3 codes (compensates for time skew)
      # -s: secret file location
      # -e 5: generate 5 emergency codes
      # -Q none: suppress google-authenticator QR (we generate our own because it would not display)
      # Pipe -1 to skip the code verification prompt (no TTY available in pam_exec)
      echo "-1" | google-authenticator -t -d -f -r 3 -R 30 -w 3 -e 5 -Q none -s "$secret"

      # Must exist and be non-empty, otherwise deny login
      if [ ! -s "$secret" ]; then
        echo ""
        echo "2FA enrollment failed or was canceled. Login denied."
        exit 1
      fi

      chmod 0600 "$secret"

      # Extract secret key and generate QR code ourselves using qrencode
      secret_key=$(head -1 "$secret")
      hostname=$(hostname)
      otpauth_url="otpauth://totp/${user}@${hostname}?secret=${secret_key}&issuer=${hostname}"

      echo ""
      echo "Scan this QR code with your authenticator app:"
      echo ""
      echo "$otpauth_url" | qrencode -t ANSIUTF8
      echo ""
      echo "Or manually enter this secret key: $secret_key"
      echo ""
      echo "Your emergency scratch codes (save these securely):"
      grep -E '^[0-9]{8}$' "$secret" | sed 's/^/  /'
      echo ""
      echo "2FA setup successful! Please use your TOTP app for future logins."
      echo "==============================================================================="

      exit 0
  when: enable_2fa | default(false)

- name: Configure PAM to force enrollment with pam_exec
  ansible.builtin.blockinfile:
    path: /etc/pam.d/sshd
    insertbefore: "@include common-auth"
    marker: "# {mark} ANSIBLE MANAGED BLOCK - 2FA enrollment and authentication"
    block: |
      # Skip 2FA for service accounts in no2fa group (e.g., ansible automation)
      # success=done means auth succeeds immediately if user is in no2fa group
      auth  [success=done default=ignore] pam_succeed_if.so user ingroup no2fa
      # Force 2FA enrollment if secret doesn't exist (denies login if canceled)
      auth  requisite pam_exec.so stdout /usr/local/sbin/ga-enroll-if-needed
      # Require 2FA authentication using centrally-stored secrets
      auth  required  pam_google_authenticator.so user=root secret=/var/lib/google-authenticator/${USER}
    state: "{{ 'present' if (enable_2fa | default(false)) else 'absent' }}"
  become: true

- name: Disable password authentication in PAM when 2FA is enabled
  ansible.builtin.replace:
    path: /etc/pam.d/sshd
    regexp: '^(@include common-auth)$'
    replace: '# \1  # Disabled for pubkey+2FA authentication'
  become: true
  when: enable_2fa | default(false)

- name: Re-enable password authentication in PAM when 2FA is disabled
  ansible.builtin.replace:
    path: /etc/pam.d/sshd
    regexp: '^# (@include common-auth).*Disabled for pubkey\+2FA.*$'
    replace: '\1'
  become: true
  when: not (enable_2fa | default(false))

- name: Remove old 2FA shell profile script if it exists
  ansible.builtin.file:
    path: /etc/profile.d/force-2fa-enrollment.sh
    state: absent

- name: Remove old 2FA enrollment script if it exists
  ansible.builtin.file:
    path: /usr/local/bin/force-2fa-enrollment
    state: absent

- name: Remove 2FA enrollment from shell profile if disabled
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop:
    - /usr/local/bin/force-2fa-enrollment
    - /etc/profile.d/force-2fa-enrollment.sh
  when: not (enable_2fa | default(false))
